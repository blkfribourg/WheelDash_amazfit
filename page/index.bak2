import { getText } from "@zos/i18n";
import * as Styles from "zosLoader:./index.[pf].layout.js";
import AutoGUI from "@silver-zepp/autogui";
import BLEMaster, {
  PERMISSIONS,
  ab2hex,
  ab2num,
  ab2str,
} from "@silver-zepp/easy-ble";
import LKDecoder from "../utils/LKDecoder";
const ble = new BLEMaster();
const AppContext = {
  MainUI: null,
  LKDecoder: null,
  BLE: null,
};

//const MAC_EUC = "88:25:83:F3:5E:E2";
const MAC_EUC = "D8:BC:38:E5:8C:F2";
//const MAC_VARIA = "CA:D1:66:93:69:67";
const MAC_VARIA = "CB:08:79:B6:C9:34";

const LK_UUID_NOTIFY_CHAR = "0000ffe1-0000-1000-8000-00805f9b34fb";

const VARIA_UUID_NOTIFY_CHAR = "6a4e3203-667b-11e3-949a-0800200c9a66";

const lk_services = {
  // service #1
  "0000ffe0-0000-1000-8000-00805f9b34fb": {
    // service UUID
    "0000ffe1-0000-1000-8000-00805f9b34fb": ["2902"], // NOTIFY chara UUID
    //  ^--- descriptor UUID
  },
  // ... add other services here if needed
};
let devices_number = 0;
const expectedDevices = 2; // Number of devices to connect to
const varia_services = {
  // service #1
  "6a4e3200-667b-11e3-949a-0800200c9a66": {
    // service UUID
    "6a4e3203-667b-11e3-949a-0800200c9a66": ["2902"], // NOTIFY chara UUID
    //  ^--- descriptor UUID
  },
  // ... add other services here if needed
};
Page({
  onInit() {
    AutoGUI.SetTextSize(20);
    //AutoGUI.SetPadding(0);
    //AutoGUI.SetBtnRadius(180);
    //AutoGUI.SetColor(COLOR_BLUE);
    //AutoGUI.SetColor(multiplyHexColor(COLOR_WHITE, 0.2));
    //AutoGUI.SetTextColor(COLOR_GREEN);
    this.indexPage = new UI();
    this.indexPage.init();

    this.BLE = new BLE();
    this.BLE.init(2);
    BLEMaster.SetDebugLevel(0);

    AppContext.MainUI = this.indexPage;
  },
  destroy() {
    ble.quit();
    this.indexPage.quit();
  },
});

class UI {
  init() {
    const gui = new AutoGUI();
    // add a text widget
    this.spd_txt = gui.text("Spd:");
    gui.newRow();
    this.vlt_txt = gui.text("Vlt:");
    gui.newRow();
    this.pwm_txt = gui.text("PWM:");
    gui.newRow();
    this.vehspd_txt = gui.text("VehSpd:");
    gui.newRow();
    this.vehdst_txt = gui.text("VehDst:");
    // split the row

    // finally render the GUI
    gui.render();
  }
  drawGUI() {
    this.mainView();
  }

  mainView() {}
}

class BLE {
  // initial setup
  init(expectedDeviceCount) {
    console.log("=========================================");
    console.log("Initializing BLE operations", Date.now());

    this.LKDecoder = new LKDecoder();
    this.LKDecoder.init();
    //  ble.quit(); //clean up everything before starting
    this.expectedDeviceCount = expectedDeviceCount;
    this.devices = {}; // mac (uppercased) → device_name
    this.scan();
    this.connections = {};
  }
  // the mac of a device you are connecting to
  scan() {
    // scan for all the devices (this step is optional)
    const scan_success = ble.startScan((scan_result) => {
      // print object with all found devices (note the return)
      console.log(JSON.stringify(ble.get.devices()));

      const device = ble.get.devices();

      const keys = Object.keys(device); // ["c8:a6:ef:e3:af:42"]

      for (let i = 0; i < keys.length; i++) {
        console.log("mac:", keys[i], "name: ", device[keys[i]].dev_name);
        const device_mac = keys[i];
        const device_name = device[keys[i]].dev_name;

        if (device_name && device_name.startsWith("Bl")) {
          console.log("LK EUC found, connecting to it");
          this.mac_handler(device_mac, device_name);
          //  this.connect(device_mac, device_name);
        }
        if (device_name && device_name.startsWith("RVR")) {
          console.log("Varia found, connecting to it");
          this.mac_handler(device_mac, device_name);
          // this.connect(device_mac, device_name);
        }
      }

      // did we find the device we were looking for?
    }); // }, { allow_duplicates: true });
  }

  mac_handler(mac, deviceName) {
    var normalizedMac = mac.toUpperCase();

    if (this.devices[normalizedMac] === undefined) {
      this.devices[normalizedMac] = deviceName;
      console.log("Stored: " + deviceName + " → " + normalizedMac);
    } else {
      console.log(
        "MAC " +
          normalizedMac +
          " already stored as " +
          this.devices[normalizedMac]
      );
    }

    var storedCount = Object.keys(this.devices).length;

    if (storedCount === this.expectedDeviceCount) {
      console.log("All expected devices received. Initiating connections...");
      var self = this;
      Object.keys(this.devices).forEach(function (mac) {
        var name = self.devices[mac];
        self.connect(mac, name);
      });
    } else {
      console.log(
        storedCount + "/" + this.expectedDeviceCount + " devices collected."
      );
    }
  }

  connect(mac, name, attempt = 1, max_attempts = 30, delay = 1000) {
    console.log("passed name: ", name);
    ble.connect(mac, (connect_result) => {
      console.log("Connect result:", JSON.stringify(connect_result));

      // try to reconnect until we get a successful connection
      if (!connect_result.connected) {
        if (attempt < max_attempts) {
          // first kill the connection
          // ble.quit(); // ble.disconnect(ble.get.connectionID());
          // retry
          console.log(
            `Attempt ${attempt} failed. Retrying in ${delay / 1000} seconds...`
          );
          setTimeout(
            () => this.connect(mac, name, attempt + 1, max_attempts, delay),
            delay
          );
        } else {
          console.log("Connection failed. Max attempts reached.");
          // handle max retry attempts reached
        }
      } else {
        // successful connection - build profile and start listener
        this.connections[mac] = { name, connected: true };
        if (name && name.startsWith("RVR")) {
          this.listen(mac, varia_services);
        }
        if (name && name.startsWith("Bl")) {
          this.listen(mac, lk_services);
        }
      }
    });
  }

  // 3. build profile and start the listener
  listen(mac, services) {
    console.log(`Starting listener for ${mac}`);
    const profile_object = ble.generateProfileObject(services);

    ble.startListener(profile_object, (response) => {
      if (response.success) {
        console.log(`Listener started for ${mac}`);
        const service_uuid = Object.keys(services); // ["c8:a6:ef:e3:af:42"]
        console.log("service uuid:", service_uuid);
        const char_uuid = Object.keys(services[service_uuid]);

        ble.write.enableCharaNotifications(char_uuid[0], true);
        ble.on.descWriteComplete((chara, desc, status) => {
          console.log(`Descriptor write complete for Characteristic UUID: ${chara}, 
                       Descriptor UUID: ${desc}, Status: ${status}`);
        });
        // Handle notifications
        ble.on.charaNotification((uuid, data, length) => {
          console.log(`Notification received from ${mac}:`, uuid, data);

          if (
            uuid === LK_UUID_NOTIFY_CHAR &&
            this.connections[mac]?.name.startsWith("Bl")
          ) {
            const result = this.LKDecoder.frameBuffer(data);
            if (result) {
              const { speed, hPWM, voltage } = result;
              if (
                AppContext.MainUI &&
                AppContext.MainUI.spd_txt &&
                AppContext.MainUI.pwm_txt &&
                AppContext.MainUI.vlt_txt
              ) {
                this.updateUI({ speed, hPWM, voltage });
              }
            }
          }

          if (
            uuid === VARIA_UUID_NOTIFY_CHAR &&
            this.connections[mac]?.name.startsWith("RVR")
          ) {
            if (variaData.byteLength >= 4) {
              const vehspd = variaData[3];
              const vehdst = variaData[2];

              if (
                AppContext.MainUI &&
                AppContext.MainUI.vehspd_txt &&
                AppContext.MainUI.vehdst_txt
              ) {
                this.updateVariaUI({ vehspd, vehdst });
              }
            }
          }
        });
      } else {
        console.log(`Failed to start listener for ${mac}`);
      }
    });
  }
  /*
  listen(services) {
    console.log("passed services: ", JSON.stringify(services));
    // generate a profile
    console.log("Generating a profile");
    const profile_object = ble.generateProfileObject(services);

    // start the listener and use full profile
    console.log("Starting the listener");
    ble.startListener(profile_object, (response) => {
      // check if the profile was built OK and the device is ready for comms
      console.log("Backend response:", response.message);
      if (response.success) {
        //  is_ble_ready = true; // gui buttons flag - allow clicking on them

        // finally manipulate - read, write, subscribe to notifications
        const service_uuid = Object.keys(services); // ["c8:a6:ef:e3:af:42"]
        console.log("service uuid:", service_uuid);
        const char_uuid = Object.keys(services[service_uuid]);
        this.communicate(char_uuid[0]); // ATTENTION CA NE MARCHERA PAS SI LE SERVICE A PLUSIEURS CARACTERISTIQUES, faudra check les caracteristics avec la propriete "notify"
      } else {
        console.log(
          `Error starting listener: ${response.message} (Code: ${response.code})`
        );
      }
    });
  }

  communicate(ntf_char) {
    console.log("passed UUID", ntf_char);
    ble.write.enableCharaNotifications(ntf_char, true);
    // let n = 0;
    ble.on.descWriteComplete((chara, desc, status) => {
      console.log(`Descriptor write complete for Characteristic UUID: ${chara}, 
                   Descriptor UUID: ${desc}, Status: ${status}`);
    });
    ble.on.charaNotification((uuid, data, length) => {
      if (uuid !== ntf_char) {
        console.log(
          "Received notification from an unexpected characteristic:",
          uuid
        );
        return;
      }

      if (!this.LKDecoder) {
        console.log("LKDecoder is not initialized.");
        return;
      }
      if (uuid === LK_UUID_NOTIFY_CHAR) {
        //      n = n + 1;
        //console.log(ab2hex(data));
        const result = this.LKDecoder.frameBuffer(data);
        if (!result) {
          //   console.log("No valid frame received yet.");
          return;
        }

        const { speed, hPWM, voltage } = result;
        //("Speed:", speed);
        //("hPWM:", hPWM);
        //("Voltage:", voltage);

        if (
          AppContext.MainUI &&
          AppContext.MainUI.spd_txt &&
          AppContext.MainUI.pwm_txt &&
          AppContext.MainUI.vlt_txt
        ) {
          this.updateUI({ speed, hPWM, voltage });
        }
      }

      if (uuid === VARIA_UUID_NOTIFY_CHAR) {
        const variaData = new Uint8Array(data);
        if (variaData.byteLength >= 4) {
          const vehspd = variaData[3];
          const vehdst = variaData[2];

          if (
            AppContext.MainUI &&
            AppContext.MainUI.vehspd_txt &&
            AppContext.MainUI.vehdst_txt
          ) {
            this.updateVariaUI({ vehspd, vehdst });
          }
        }
        //      n = n + 1;
        //console.log(ab2hex(data));
      }
    });
  }
*/
  // Method to update the UI
  updateUI({ speed, hPWM, voltage }) {
    try {
      if (AppContext.MainUI?.spd_txt?.update) {
        AppContext.MainUI.spd_txt.update({ text: "Spd: " + speed });
      } else {
        console.log(
          "spd_txt is not properly initialized or missing an update method."
        );
      }

      if (AppContext.MainUI?.pwm_txt?.update) {
        AppContext.MainUI.pwm_txt.update({ text: "PWM: " + hPWM });
      } else {
        console.log(
          "pwm_txt is not properly initialized or missing an update method."
        );
      }

      if (AppContext.MainUI?.vlt_txt?.update) {
        AppContext.MainUI.vlt_txt.update({ text: "Vlt: " + voltage });
      } else {
        console.log(
          "vlt_txt is not properly initialized or missing an update method."
        );
      }
    } catch (error) {
      console.log("Error updating UI:", error);
    }
  }

  // Method to update the VariaUI
  updateVariaUI({ vehspd, vehdst }) {
    try {
      if (AppContext.MainUI?.vehspd_txt.update) {
        AppContext.MainUI.vehspd_txt.update({ text: "Vehspd: " + vehspd });
      } else {
        console.log(
          "spd_txt is not properly initialized or missing an update method."
        );
      }

      if (AppContext.MainUI?.vehdst_txt?.update) {
        AppContext.MainUI.vehdst_txt.update({ text: "Vehdst: " + vehdst });
      } else {
        console.log(
          "pwm_txt is not properly initialized or missing an update method."
        );
      }
    } catch (error) {
      console.log("Error updating varia UI:", error);
    }
  }
}
